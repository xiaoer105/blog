---
title: "TCP 三次握手和四次挥手"
date: 2021-10-08T10:34:00+08:00
draft: false
toc: true
images:
tags: 
  - tcp
---

我们在了解握手和挥手过程之前，先了解一些常用的名词。

- seq：seq（Sequence Number）记录包的序号（第一次请求时会随机产生一个值，之后+1），TCP 会按照报文字节进行编号，解决包在网络中乱序的问题。
- ack：ack（Acknowledgement Number）确认序列号，接收上一条信息的 seq+1，用于向发送发确认已经收到哪些包，解决不丢包问题
- SYN：同步标志。该标志仅在 TCP 三次握手时有效，发起新的连接请求时，为1。
- FIN：结束标志。释放一个连接请求时，为1。
- ACK：ACK 确认标志。与 ack 不同，TCP 协议规定，当连接建立后所有的报文的 ACK 必须为1。
- PSH：PSH（push）推标志。该标志位有效时，服务端不在对该数据进行队列处理，而是尽可能将数据转交给应用处理。
- RST：RST（reset）复位标志。用于复位相应的 TCP 连接。 
- URG：URG（urgent）紧急标志。为1是有效。

更多可以了解参考 [《TCP 报文长什么样子》]() 这篇文章。

## 三次握手
三次握手指的是建立 TCP 连接的过程。

第一次握手：客户端发送一个 TCP 的 SYN 标志位为 1（连接请求）的包，并初始化序号 x，保存在包头的序列号（Sequence Number）字段里，发送完毕，客户端进入 SYN_SEND（同步发送） 状态，等到服务端确认。

第二次握手：服务端收到来自客户端的连接请求后，同意连接会发送确认包（ACK）进行应答。
SYN 和 ACK 标志位都为 1，服务端生成属于自己的 INS 序号 y，放到 Seq 里，同时将确认序号设置为客户端发送的 ISN+1，即 x+1，发送给客户端，发送成功后，服务端进入 SYN_RCVD（同步收到） 状态。

第三次握手：客户端收到服务端发送确认包后，客户端再次发送确认包（ACK），SYN 标志位为 0，ACK 标志位为 1，确认序号设置为服务端发送的 ISN+1（ack=y+1），自己序列号+1（seq=x+1），
发送成功后，客户端进入 ESTABLISHED（已建立连接）状态，服务端收到这个包后也进入 ESTABLISHED 状态，这样双方建立了通信，TCP 握手结束。

### 为什么是三次握手，二次握手可以吗
二次握手会使得 TCP 变得不那么可靠，具体可以从以下几个方面进行说明：

#### 1.确认双方接收和发送的能力

TCP连接之前，需要确保客户端和服务端接收包和发送包能力的正常

第一次握手：客户端发送网络包给服务端，服务端收到了，说明客户端发包、服务端收包的功能正常。

第二次握手：服务端收到包后，发送确认包给客户端，客户端收到后，说明服务端收包和发包、客户端收包和发包都正常，但是此时服务端并不知道客户端是否已经收到了，不确定客户端收包能力。

第三次握手：客户端发送确认包，服务端收到后，可以得出客户端和服务端的收包、发包能力正常。

之后三次握手才能够得出双方的接收和发送能力是否正常。

#### 2.保证序列号可靠同步
TCP 为了实现可靠的数据传输，引入序号（Sequence Number）和确认号（Acknowledgement Number）的使用。
通信双方需要确认自己发送的序号是否有被对方接收到，如果没有接收到，那么需要进行重发。

如果使用二次握手，那么服务端是不知道客户端是否成功收到自己发送的序列号。或者第二次报文丢失，客户端不知道服务端的初始序列号，对于 TCP 来说毫无可靠性而言。

#### 3.避免重复初始化连接
如果客户端同时发送了两个不同序号的 SYN 包，使用二次握手，会导致服务端接收到旧的数据包，并建立连接，会照成网络异常。

使用三次握手，服务器需要回复 ACK+SYN 包，客户端会对确认包中的确认号进行确认，如果客户端发送的是旧的 SYN 报文，服务端回复客户端的 ACK 中的确认号是旧序号，客户端收到后进行判断发现序号不对，会给服务器发送 RST 报文，直到正常的 SYN 包到达服务端之后，才建立连接。

#### 4.安全问题
TCP 新建连接时，内核会为连接分配一系列的内存资源，如果使用2次握手，会放大 DDos 攻击。

具体参考[SYN 攻击]({{< relref "#syn-攻击" >}})。

### INS是固定的吗
INS（Initial Sequence Number）初始序列号，每次建立连接时，动态生成的。

### 三次握手过程中可以携带数据吗
TCP 协议规定 SYN 报文段（SYN=1）是不能携带数据，但是需要消耗一个序号。ACK 报文段是可以携带数据的，如果没有携带数据那么不消耗序号。

在第一次、第二次握手过程中是不允许携带数据，第三次握手允许携带数据（默认不携带数据）。

如果第一次是允许携带数据的，那么有人要恶意攻击服务器的话，只需要每次在第一握手种的 SYN 报文中放入大量的数据，一直重复的发送 SYN 报文，这样会让服务器花费大量的内存空间来缓存这些报文，服务器很容易被攻击。

对于第三次握手可以携带数据，因为此时的客户端已经处于连接状态，确认了服务端接收和发送的能力，携带数据也属于正常。

### 什么是半连接队列
半连接指的是服务端发送 ACK-SYN之后，收到客户端 ACK 之前的连接。

也就是服务端在第一次收到客户端的 SYN 报文时，双方没有完全建立连接，处于 SYNC_RCVD 状态，服务端把这种连接状态放到一个队列里面，也就是半连接队列。

### 什么是全连接队列
全连接指的是服务端收到来自客户端的 ACK，也就是已经完成三次握手的连接会被放到全连接队列里面。

如果队列满了，就有可能出现丢包的现象。

### SYN 攻击
SYN 攻击是一种典型的 Dos/DDos 攻击。

SYN 攻击指的是客户端在短时间伪造了大量不存在的 IP 地址，向服务端不断发送 SYN 包，服务器回复确认包，并等待客户端的确认。
因为源地址 IP 是不存在的，所以服务端需要不断进行重发直到超时，这些伪造的 SYN 包将长时间占用未连接队列，导致队列暂满，正常的 SYN 请求连接被丢失，目标系统运行缓慢，严重会引发网络拥塞甚至瘫痪。

#### 如何检测
linux 可以通过 `netstat` 命令查看连接状态，如果出现大量的半连接状态，并且源 IP 地址是随机的，那么就可以断定这是一次 SYN 攻击了。

#### 如何预防
SYN 攻击不能完全的阻止，但是可以通过一些手段尽可能地减少 SYN 攻击带来的危害，常见的预防 SYN 攻击的方式有：
1. 缩短超时时间
2. 增加最大半连接数
3. 过滤网关防护
4.  SYN cookies 技术

## 四次挥手
所谓四次挥手指的是 TCP 断开连接的过程，需要客户端和服务端一共发送4个包来确认连接的断开，也叫做改进的三次握手。

客户端和服务端都可以主动发起挥手动作，在 socket 编程中，任意一方都可以进行关闭连接，执行挥手操作。

第一次挥手：客户端想要关闭连接，需要发送一个 FIN 标志位为1的包（自己已经没有数据可以发送了，但是任然可以接收数据）至服务端，发送完毕后，客户端进入 FIN_WAIT_1（终止等待1） 状态。

第二次挥手：服务端收到客户端的 FIN 包，需要发送一个确认包，表示自己收到了来自客户端的关闭连接请求，但是此时服务端还没有完全关闭连接，因为服务端可能还有数据需要处理。
发送成功后，服务端进入 CLOSE_WAIT（关闭等待）状态（半关闭连接）。客户端收到服务端的确认包后，进入 FIN_WAIT_2（终止等待2） 状态，等待服务端关闭连接（此时还可以接收来自服务端发送的数据）。

第三次握手：
服务端处理（发送）所有的数据之后，就可以向客户端发送 FIN 标志位为1的包，发送成功后，服务端进入 LAST_ACK（最后确认） 状态，等待接收客户端发送的最后一个 ACk 确认包。

第四次握手：客户端收到服务端的 FIN 包后，发送一个确认包，进入 TIME_WAIT（时间等待） 状态，等待服务端的确认。

客户端在等待某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有服务端的 ACK，认为服务端已经正常关闭连接，于是自己也关闭连接，进入 CLOSE 状态。

服务端收到这个确认包之后，关闭连接，进入 CLOSE 状态（服务端关闭连接的时间要比客户端早一些）。

四次挥手结束，TCP 连接关闭。

### 为什么建立连接是三次握手，关闭连接是四次挥手呢
首先在 TCP 握手过程中，服务端在收到客户端的 SYN 包后，将 ACK+SYN 包（ACK包和SYN包）合并成一个包中，发送给客户端，减少一次包的发送，三次完成握手操作。

四次挥手，服务端在第一次收到来自客户端的 FIN 报文时，服务端可能还在处理数据，还需要发送数据给客户端，此时并不能立即进行关闭，所有不能和握手一样将 ACK 和 SYN 包合并成一个包发送，
只能先回复 ACK 包确认，等待服务端无数据发送，在发送 FIN 包到客户端，所有四次挥手需要进行4次数据包的交互。

### 为什么 TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？
我们先来了解下什么时 MSL，MSL指的是一个报文在网络中最大的生存时间（ACK 到达服务器+服务器发送 FIN 重传包）。

简单认识 MSL 之后，回来上面的问题，主要存在两个原因：

#### 保证连接能够可靠的关闭
如果客户端收到服务端的 FIN 包，并进行回复 ACK 确认包之后，直接关闭连接，那么会出现网络等其他问题导致 ACK 确认包没有发出去，服务端在一定时间内没有收到来自客户端的 ACK 确认包导致超时，服务端会再次向客户端发送 FIN 包，如果此时客户端已经关闭了，会导致服务端 FIN 包发送不出去。

#### 避免新连接与旧连接发生混淆
客户端关闭连接的同时又向服务端建立连接，假如两次连接的端口号一致，且旧连接中有些数据滞带在网络中，这些延迟数据在新连接之后才到达服务端，服务端会把旧连接产生的延时数据认为是新连接产生的，导致数据包混淆。

## 参考地址
[https://segmentfault.com/a/1190000039165592](https://segmentfault.com/a/1190000039165592)

[https://www.eet-china.com/mp/a44399.html](https://www.eet-china.com/mp/a44399.html)

[https://www.jianshu.com/p/ef892323e68f](https://www.jianshu.com/p/ef892323e68f)